{
  "version": 3,
  "sources": ["../../../../../../node_modules/papaparse/papaparse.js"],
  "sourcesContent": ["/* @license\nPapa Parse\nv5.5.3\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\n\n(function(root, factory)\n{\n\t/* globals define */\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && typeof exports !== 'undefined')\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n\t// in strict mode we cannot access arguments.callee, so we need a named reference to\n\t// stringify the factory method for the blob worker\n\t// eslint-disable-next-line func-name\n}(this, function moduleFactory()\n{\n\t'use strict';\n\n\tvar global = (function() {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n\t\t// When running tests none of the above have been defined\n\t\treturn {};\n\t})();\n\n\n\tfunction getWorkerBlob() {\n\t\tvar URL = global.URL || global.webkitURL || null;\n\t\tvar code = moduleFactory.toString();\n\t\treturn Papa.BLOB_URL || (Papa.BLOB_URL = URL.createObjectURL(new Blob([\"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \", '(', code, ')();'], {type: 'text/javascript'})));\n\t}\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = global.IS_PAPA_WORKER || false;\n\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.NODE_STREAM_INPUT = 1;\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tPapa.DuplexStreamStreamer = DuplexStreamStreamer;\n\t}\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t};\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n\t\tvar dynamicTyping = _config.dynamicTyping || false;\n\t\tif (isFunction(dynamicTyping)) {\n\t\t\t_config.dynamicTypingFunction = dynamicTyping;\n\t\t\t// Will be filled on first row call\n\t\t\tdynamicTyping = {};\n\t\t}\n\t\t_config.dynamicTyping = dynamicTyping;\n\n\t\t_config.transform = isFunction(_config.transform) ? _config.transform : false;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (_input === Papa.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT === 'undefined')\n\t\t{\n\t\t\t// create a node Duplex stream for use\n\t\t\t// with .pipe\n\t\t\tstreamer = new DuplexStreamStreamer(_config);\n\t\t\treturn streamer.getStream();\n\t\t}\n\t\telse if (typeof _input === 'string')\n\t\t{\n\t\t\t_input = stripBom(_input);\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\n\t\t// Strip character from UTF-8 BOM encoded files that cause issue parsing the file\n\t\tfunction stripBom(string) {\n\t\t\tif (string.charCodeAt(0) === 0xfeff) {\n\t\t\t\treturn string.slice(1);\n\t\t\t}\n\t\t\treturn string;\n\t\t}\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character(s) */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\t/** escaped quote character, either \"\" or <config.escapeChar>\" */\n\t\tvar _escapedQuote = _quoteChar + _quoteChar;\n\n\t\t/** whether to skip empty lines */\n\t\tvar _skipEmptyLines = false;\n\n\t\t/** the columns (keys) we expect when we unparse objects */\n\t\tvar _columns = null;\n\n\t\t/** whether to prevent outputting cells that can be parsed as formulae by spreadsheet software (Excel and LibreOffice) */\n\t\tvar _escapeFormulae = false;\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(escapeRegExp(_quoteChar), 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (Array.isArray(_input))\n\t\t{\n\t\t\tif (!_input.length || Array.isArray(_input[0]))\n\t\t\t\treturn serialize(null, _input, _skipEmptyLines);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(_columns || Object.keys(_input[0]), _input, _skipEmptyLines);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (Array.isArray(_input.data))\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields = _input.meta && _input.meta.fields || _columns;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  Array.isArray(_input.data[0])\n\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t: typeof _input.data[0] === 'object'\n\t\t\t\t\t\t\t? Object.keys(_input.data[0])\n\t\t\t\t\t\t\t: [];\n\n\t\t\t\tif (!(Array.isArray(_input.data[0])) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || [], _skipEmptyLines);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow new Error('Unable to serialize unrecognized input');\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n                && !Papa.BAD_DELIMITERS.filter(function(value) { return _config.delimiter.indexOf(value) !== -1; }).length)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| typeof _config.quotes === 'function'\n\t\t\t\t|| Array.isArray(_config.quotes))\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.skipEmptyLines === 'boolean'\n\t\t\t\t|| typeof _config.skipEmptyLines === 'string')\n\t\t\t\t_skipEmptyLines = _config.skipEmptyLines;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\n\t\t\tif (Array.isArray(_config.columns)) {\n\n\t\t\t\tif (_config.columns.length === 0) throw new Error('Option columns is empty');\n\n\t\t\t\t_columns = _config.columns;\n\t\t\t}\n\n\t\t\tif (_config.escapeChar !== undefined) {\n\t\t\t\t_escapedQuote = _config.escapeChar + _quoteChar;\n\t\t\t}\n\n\t\t\tif (_config.escapeFormulae instanceof RegExp) {\n\t\t\t\t_escapeFormulae = _config.escapeFormulae;\n\t\t\t} else if (typeof _config.escapeFormulae === 'boolean' && _config.escapeFormulae) {\n\t\t\t\t_escapeFormulae =  /^[=+\\-@\\t\\r].*$/;\n\t\t\t}\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data, skipEmptyLines)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = Array.isArray(fields) && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(Array.isArray(data[0]));\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tvar emptyLine = false;\n\t\t\t\tvar nullLine = hasHeader ? Object.keys(data[row]).length === 0 : data[row].length === 0;\n\t\t\t\tif (skipEmptyLines && !hasHeader)\n\t\t\t\t{\n\t\t\t\t\temptyLine = skipEmptyLines === 'greedy' ? data[row].join('').trim() === '' : data[row].length === 1 && data[row][0].length === 0;\n\t\t\t\t}\n\t\t\t\tif (skipEmptyLines === 'greedy' && hasHeader) {\n\t\t\t\t\tvar line = [];\n\t\t\t\t\tfor (var c = 0; c < maxCol; c++) {\n\t\t\t\t\t\tvar cx = dataKeyedByField ? fields[c] : c;\n\t\t\t\t\t\tline.push(data[row][cx]);\n\t\t\t\t\t}\n\t\t\t\t\temptyLine = line.join('').trim() === '';\n\t\t\t\t}\n\t\t\t\tif (!emptyLine)\n\t\t\t\t{\n\t\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (col > 0 && !nullLine)\n\t\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t\t}\n\t\t\t\t\tif (row < data.length - 1 && (!skipEmptyLines || (maxCol > 0 && !nullLine)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcsv += _newline;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tif (str.constructor === Date)\n\t\t\t\treturn JSON.stringify(str).slice(1, 25);\n\n\t\t\tvar needsQuotes = false;\n\n\t\t\tif (_escapeFormulae && typeof str === \"string\" && _escapeFormulae.test(str)) {\n\t\t\t\tstr = \"'\" + str;\n\t\t\t\tneedsQuotes = true;\n\t\t\t}\n\n\t\t\tvar escapedQuoteStr = str.toString().replace(quoteCharRegex, _escapedQuote);\n\n\t\t\tneedsQuotes = needsQuotes\n\t\t\t\t\t\t\t|| _quotes === true\n\t\t\t\t\t\t\t|| (typeof _quotes === 'function' && _quotes(str, col))\n\t\t\t\t\t\t\t|| (Array.isArray(_quotes) && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(escapedQuoteStr, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| escapedQuoteStr.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(0) === ' '\n\t\t\t\t\t\t\t|| escapedQuoteStr.charAt(escapedQuoteStr.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + escapedQuoteStr + _quoteChar : escapedQuoteStr;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._finished = false;\n\t\tthis._completed = false;\n\t\tthis._halted = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk, isFakeChunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tconst skipFirstNLines = parseInt(this._config.skipFirstNLines) || 0;\n\t\t\tif (this.isFirstChunk && skipFirstNLines > 0) {\n\t\t\t\tlet _newline = this._config.newline;\n\t\t\t\tif (!_newline) {\n\t\t\t\t\tconst quoteChar = this._config.quoteChar || '\"';\n\t\t\t\t\t_newline = this._handle.guessLineEndings(chunk, quoteChar);\n\t\t\t\t}\n\t\t\t\tconst splitChunk = chunk.split(_newline);\n\t\t\t\tchunk = [...splitChunk.slice(skipFirstNLines)].join(_newline);\n\t\t\t}\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\t\t\tthis._halted = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\tthis._halted = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk) && !isFakeChunk)\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._handle.paused() || this._handle.aborted()) {\n\t\t\t\t\tthis._halted = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (!this._completed && finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted)) {\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\t\t\t\tthis._completed = true;\n\t\t\t}\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open(this._config.downloadRequestBody ? 'POST' : 'GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes=' + this._start + '-' + end);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send(this._config.downloadRequestBody);\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t};\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState !== 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Use chunckSize as it may be a diference on reponse lentgh due to characters with more than 1 byte\n\t\t\tthis._start += this._config.chunkSize ? this._config.chunkSize : xhr.responseText.length;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t};\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(new Error(errorText));\n\t\t};\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn parseInt(contentRange.substring(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t};\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t};\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t};\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t};\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk;\n\t\t\tif(size) {\n\t\t\t\tchunk = remaining.substring(0, size);\n\t\t\t\tremaining = remaining.substring(size);\n\t\t\t} else {\n\t\t\t\tchunk = remaining;\n\t\t\t\tremaining = '';\n\t\t\t}\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t};\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\t\tvar streamHasEnded = false;\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.pause.apply(this, arguments);\n\t\t\tthis._input.pause();\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tChunkStreamer.prototype.resume.apply(this, arguments);\n\t\t\tthis._input.resume();\n\t\t};\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t};\n\n\t\tthis._checkIsFinished = function()\n\t\t{\n\t\t\tif (streamHasEnded && queue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tthis._checkIsFinished();\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis._checkIsFinished();\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tstreamHasEnded = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\tfunction DuplexStreamStreamer(_config) {\n\t\tvar Duplex = require('stream').Duplex;\n\t\tvar config = copy(_config);\n\t\tvar parseOnWrite = true;\n\t\tvar writeStreamHasFinished = false;\n\t\tvar parseCallbackQueue = [];\n\t\tvar stream = null;\n\n\t\tthis._onCsvData = function(results)\n\t\t{\n\t\t\tvar data = results.data;\n\t\t\tif (!stream.push(data) && !this._handle.paused()) {\n\t\t\t\t// the writeable consumer buffer has filled up\n\t\t\t\t// so we need to pause until more items\n\t\t\t\t// can be processed\n\t\t\t\tthis._handle.pause();\n\t\t\t}\n\t\t};\n\n\t\tthis._onCsvComplete = function()\n\t\t{\n\t\t\t// node will finish the read stream when\n\t\t\t// null is pushed\n\t\t\tstream.push(null);\n\t\t};\n\n\t\tconfig.step = bindFunction(this._onCsvData, this);\n\t\tconfig.complete = bindFunction(this._onCsvComplete, this);\n\t\tChunkStreamer.call(this, config);\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (writeStreamHasFinished && parseCallbackQueue.length === 1) {\n\t\t\t\tthis._finished = true;\n\t\t\t}\n\t\t\tif (parseCallbackQueue.length) {\n\t\t\t\tparseCallbackQueue.shift()();\n\t\t\t} else {\n\t\t\t\tparseOnWrite = true;\n\t\t\t}\n\t\t};\n\n\t\tthis._addToParseQueue = function(chunk, callback)\n\t\t{\n\t\t\t// add to queue so that we can indicate\n\t\t\t// completion via callback\n\t\t\t// node will automatically pause the incoming stream\n\t\t\t// when too many items have been added without their\n\t\t\t// callback being invoked\n\t\t\tparseCallbackQueue.push(bindFunction(function() {\n\t\t\t\tthis.parseChunk(typeof chunk === 'string' ? chunk : chunk.toString(config.encoding));\n\t\t\t\tif (isFunction(callback)) {\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t}, this));\n\t\t\tif (parseOnWrite) {\n\t\t\t\tparseOnWrite = false;\n\t\t\t\tthis._nextChunk();\n\t\t\t}\n\t\t};\n\n\t\tthis._onRead = function()\n\t\t{\n\t\t\tif (this._handle.paused()) {\n\t\t\t\t// the writeable consumer can handle more data\n\t\t\t\t// so resume the chunk parsing\n\t\t\t\tthis._handle.resume();\n\t\t\t}\n\t\t};\n\n\t\tthis._onWrite = function(chunk, encoding, callback)\n\t\t{\n\t\t\tthis._addToParseQueue(chunk, callback);\n\t\t};\n\n\t\tthis._onWriteComplete = function()\n\t\t{\n\t\t\twriteStreamHasFinished = true;\n\t\t\t// have to write empty string\n\t\t\t// so parser knows its done\n\t\t\tthis._addToParseQueue('');\n\t\t};\n\n\t\tthis.getStream = function()\n\t\t{\n\t\t\treturn stream;\n\t\t};\n\t\tstream = new Duplex({\n\t\t\treadableObjectMode: true,\n\t\t\tdecodeStrings: false,\n\t\t\tread: bindFunction(this._onRead, this),\n\t\t\twrite: bindFunction(this._onWrite, this)\n\t\t});\n\t\tstream.once('finish', bindFunction(this._onWriteComplete, this));\n\t}\n\tif (typeof PAPA_BROWSER_CONTEXT === 'undefined') {\n\t\tDuplexStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\t\tDuplexStreamStreamer.prototype.constructor = DuplexStreamStreamer;\n\t}\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar MAX_FLOAT = Math.pow(2, 53);\n\t\tvar MIN_FLOAT = -MAX_FLOAT;\n\t\tvar FLOAT = /^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/;\n\t\tvar ISO_DATE = /^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/;\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _rowCounter = 0;\t// Number of rows that have been parsed so far\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;\t// Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse {\n\t\t\t\t\t\t_results.data = _results.data[0];\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tvar quoteChar = _config.quoteChar || '\"';\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = this.guessLineEndings(input, quoteChar);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline, _config.skipEmptyLines, _config.comments, _config.delimitersToGuess);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\n\t\t\t// If it is streaming via \"chunking\", the reader will start appending correctly already so no need to substring,\n\t\t\t// otherwise we can get duplicate content within a row\n\t\t\t_input = isFunction(_config.chunk) ? \"\" : _input.substring(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\tif(self.streamer._halted) {\n\t\t\t\t_paused = false;\n\t\t\t\tself.streamer.parseChunk(_input, true);\n\t\t\t} else {\n\t\t\t\t// Bugfix: #636 In case the processing hasn't halted yet\n\t\t\t\t// wait for it to halt in order to resume\n\t\t\t\tsetTimeout(self.resume, 3);\n\t\t\t}\n\t\t};\n\n\t\tthis.aborted = function()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tthis.guessLineEndings = function(input, quoteChar)\n\t\t{\n\t\t\tinput = input.substring(0, 1024 * 1024);\t// max length 1 MB\n\t\t\t// Replace all the text inside quotes\n\t\t\tvar re = new RegExp(escapeRegExp(quoteChar) + '([^]*?)' + escapeRegExp(quoteChar), 'gm');\n\t\t\tinput = input.replace(re, '');\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t};\n\n\t\tfunction testEmptyLine(s) {\n\t\t\treturn _config.skipEmptyLines === 'greedy' ? s.join('').trim() === '' : s.length === 1 && s[0].length === 0;\n\t\t}\n\n\t\tfunction testFloat(s) {\n\t\t\tif (FLOAT.test(s)) {\n\t\t\t\tvar floatValue = parseFloat(s);\n\t\t\t\tif (floatValue > MIN_FLOAT && floatValue < MAX_FLOAT) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\'' + Papa.DefaultDelimiter + '\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\t_results.data = _results.data.filter(function(d) {\n\t\t\t\t\treturn !testEmptyLine(d);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTypingAndTransformation();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\n\t\t\tfunction addHeader(header, i)\n\t\t\t{\n\t\t\t\tif (isFunction(_config.transformHeader))\n\t\t\t\t\theader = _config.transformHeader(header, i);\n\n\t\t\t\t_fields.push(header);\n\t\t\t}\n\n\t\t\tif (Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\t\t_results.data[i].forEach(addHeader);\n\n\t\t\t\t_results.data.splice(0, 1);\n\t\t\t}\n\t\t\t// if _results.data[0] is not an array, we are in a step where _results.data is the row.\n\t\t\telse\n\t\t\t\t_results.data.forEach(addHeader);\n\t\t}\n\n\t\tfunction shouldApplyDynamicTyping(field) {\n\t\t\t// Cache function values to avoid calling it for each row\n\t\t\tif (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n\t\t\t\t_config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n\t\t\t}\n\t\t\treturn (_config.dynamicTyping[field] || _config.dynamicTyping) === true;\n\t\t}\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse if (testFloat(value))\n\t\t\t\t\treturn parseFloat(value);\n\t\t\t\telse if (ISO_DATE.test(value))\n\t\t\t\t\treturn new Date(value);\n\t\t\t\telse\n\t\t\t\t\treturn (value === '' ? null : value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTypingAndTransformation()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping && !_config.transform))\n\t\t\t\treturn _results;\n\n\t\t\tfunction processRow(rowSource, i)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tvar j;\n\t\t\t\tfor (j = 0; j < rowSource.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = rowSource[j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tif (_config.transform)\n\t\t\t\t\t\tvalue = _config.transform(value,field);\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, _rowCounter + i);\n\t\t\t\t}\n\n\t\t\t\treturn row;\n\t\t\t}\n\n\t\t\tvar incrementBy = 1;\n\t\t\tif (!_results.data.length || Array.isArray(_results.data[0]))\n\t\t\t{\n\t\t\t\t_results.data = _results.data.map(processRow);\n\t\t\t\tincrementBy = _results.data.length;\n\t\t\t}\n\t\t\telse\n\t\t\t\t_results.data = processRow(_results.data, 0);\n\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\n\t\t\t_rowCounter += incrementBy;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline, skipEmptyLines, comments, delimitersToGuess) {\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow, maxFieldCount;\n\n\t\t\tdelimitersToGuess = delimitersToGuess || [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\n\t\t\tfor (var i = 0; i < delimitersToGuess.length; i++) {\n\t\t\t\tvar delim = delimitersToGuess[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0, emptyLinesCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tcomments: comments,\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++) {\n\t\t\t\t\tif (skipEmptyLines && testEmptyLine(preview.data[j])) {\n\t\t\t\t\t\temptyLinesCount++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined') {\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 0) {\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= (preview.data.length - emptyLinesCount);\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta <= bestDelta)\n\t\t\t\t\t&& (typeof maxFieldCount === 'undefined' || avgFieldCount > maxFieldCount) && avgFieldCount > 1.99) {\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t\tmaxFieldCount = avgFieldCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t};\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\tvar error = {\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg\n\t\t\t};\n\t\t\tif(row !== undefined) {\n\t\t\t\terror.row = row;\n\t\t\t}\n\t\t\t_results.errors.push(error);\n\t\t}\n\t}\n\n\t/** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions */\n\tfunction escapeRegExp(string)\n\t{\n\t\treturn string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n\t}\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar;\n\t\tvar renamedHeaders = null;\n\t\tvar headerParsed = false;\n\n\t\tif (config.quoteChar === undefined || config.quoteChar === null) {\n\t\t\tquoteChar = '\"';\n\t\t} else {\n\t\t\tquoteChar = config.quoteChar;\n\t\t}\n\t\tvar escapeChar = quoteChar;\n\t\tif (config.escapeChar !== undefined) {\n\t\t\tescapeChar = config.escapeChar;\n\t\t}\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow new Error('Comment character same as delimiter');\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline !== '\\n' && newline !== '\\r' && newline !== '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow new Error('Input must be a string');\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\trow = rows[i];\n\t\t\t\t\tcursor += row.length;\n\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substring(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(escapeRegExp(escapeChar) + escapeRegExp(quoteChar), 'g');\n\t\t\tvar quoteSearch = input.indexOf(quoteChar, cursor);\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tquoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, quoteSearch + 1);\n\n\t\t\t\t\t\t//No other quotes are found - no other delimiters\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\tif (quoteSearch === inputLen - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\t// If the quote character is the escape character, then check if the next character is the escape character\n\t\t\t\t\t\tif (quoteChar === escapeChar &&  input[quoteSearch + 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If the quote character is not the escape character, then check if the previous character was the escape character\n\t\t\t\t\t\tif (quoteChar !== escapeChar && quoteSearch !== 0 && input[quoteSearch - 1] === escapeChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(nextDelim !== -1 && nextDelim < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(nextNewline !== -1 && nextNewline < (quoteSearch + 1)) {\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, (quoteSearch + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check up to nextDelim or nextNewline, whichever is closest\n\t\t\t\t\t\tvar checkUpTo = nextNewline === -1 ? nextDelim : Math.min(nextDelim, nextNewline);\n\t\t\t\t\t\tvar spacesBetweenQuoteAndDelimiter = extraSpaces(checkUpTo);\n\n\t\t\t\t\t\t// Closing quote followed by delimiter or 'unnecessary spaces + delimiter'\n\t\t\t\t\t\tif (input.substr(quoteSearch + 1 + spacesBetweenQuoteAndDelimiter, delimLen) === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen;\n\n\t\t\t\t\t\t\t// If char after following delimiter is not quoteChar, we find next quote char position\n\t\t\t\t\t\t\tif (input[quoteSearch + 1 + spacesBetweenQuoteAndDelimiter + delimLen] !== quoteChar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar spacesBetweenQuoteAndNewLine = extraSpaces(nextNewline);\n\n\t\t\t\t\t\t// Closing quote followed by newline or 'unnecessary spaces + newLine'\n\t\t\t\t\t\tif (input.substring(quoteSearch + 1 + spacesBetweenQuoteAndNewLine, quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + spacesBetweenQuoteAndNewLine + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\t\t\t\t\t\t\tquoteSearch = input.indexOf(quoteChar, cursor);\t// we search for first quote in next line\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// Checks for valid closing quotes are complete (escaped quotes or quote followed by EOF/delimiter/newline) -- assume these quotes are part of an invalid text string\n\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\tcode: 'InvalidQuotes',\n\t\t\t\t\t\t\tmessage: 'Trailing quote on quoted field is malformed',\n\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substring(cursor, cursor + commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\t// we look for next delimiter char\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n             * checks if there are extra spaces after closing quote and given index without any text\n             * if Yes, returns the number of spaces\n             */\n\t\t\tfunction extraSpaces(index) {\n\t\t\t\tvar spaceLength = 0;\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tvar textBetweenClosingQuoteAndIndex = input.substring(quoteSearch + 1, index);\n\t\t\t\t\tif (textBetweenClosingQuoteAndIndex && textBetweenClosingQuoteAndIndex.trim() === '') {\n\t\t\t\t\t\tspaceLength = textBetweenClosingQuoteAndIndex.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn spaceLength;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substring(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\tif (config.header && !baseIndex && data.length && !headerParsed)\n\t\t\t\t{\n\t\t\t\t\tconst result = data[0];\n\t\t\t\t\tconst headerCount = Object.create(null); // To track the count of each base header\n\t\t\t\t\tconst usedHeaders = new Set(result); // To track used headers and avoid duplicates\n\t\t\t\t\tlet duplicateHeaders = false;\n\n\t\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\t\tlet header = result[i];\n\t\t\t\t\t\tif (isFunction(config.transformHeader))\n\t\t\t\t\t\t\theader = config.transformHeader(header, i);\n\n\t\t\t\t\t\tif (!headerCount[header]) {\n\t\t\t\t\t\t\theaderCount[header] = 1;\n\t\t\t\t\t\t\tresult[i] = header;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet newHeader;\n\t\t\t\t\t\t\tlet suffixCount = headerCount[header];\n\n\t\t\t\t\t\t\t// Find a unique new header\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tnewHeader = `${header}_${suffixCount}`;\n\t\t\t\t\t\t\t\tsuffixCount++;\n\t\t\t\t\t\t\t} while (usedHeaders.has(newHeader));\n\n\t\t\t\t\t\t\tusedHeaders.add(newHeader); // Mark this new Header as used\n\t\t\t\t\t\t\tresult[i] = newHeader;\n\t\t\t\t\t\t\theaderCount[header]++;\n\t\t\t\t\t\t\tduplicateHeaders = true;\n\t\t\t\t\t\t\tif (renamedHeaders === null) {\n\t\t\t\t\t\t\t\trenamedHeaders = {};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trenamedHeaders[newHeader] = header;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tusedHeaders.add(header); // Ensure the original header is marked as used\n\t\t\t\t\t}\n\t\t\t\t\tif (duplicateHeaders) {\n\t\t\t\t\t\tconsole.warn('Duplicate headers found and renamed.');\n\t\t\t\t\t}\n\t\t\t\t\theaderParsed = true;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0),\n\t\t\t\t\t\trenamedHeaders: renamedHeaders\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [];\n\t\t\t\terrors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\n\t\tvar workerUrl = getWorkerBlob();\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: msg.results.data[i],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow new Error('Not implemented.');\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object' || obj === null)\n\t\t\treturn obj;\n\t\tvar cpy = Array.isArray(obj) ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n"],
  "mappings": "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",
  "names": ["config", "xhr", "self", "i", "row", "value"]
}
